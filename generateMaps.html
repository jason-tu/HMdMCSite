<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- layout style -->
    <link href="mystyle.css" rel="stylesheet" type="text/css">
    <script src="js/jquery.min.js">
    </script>
    <script src="js/bootstrap.min.js">
    </script>
    <script src="http://code.jquery.com/jquery-2.0.0.min.js" type="text/javascript">
    </script>


    <script type="text/javascript" src="js/util.js"></script>
    <script type="text/javascript" src="js/input.js"></script>
    <script type="text/javascript" src="js/resources.js"></script>
    <script type="text/javascript" src="js/sprite.js"></script>
    <script type="text/javascript" src="js/entity.js"></script>
    <script type="text/javascript" src="js/pipe.js"></script>
    <script type="text/javascript" src="js/mushroom.js"></script>
    <script type="text/javascript" src="js/fireflower.js"></script>
    <script type="text/javascript" src="js/star.js"></script>
    <script type="text/javascript" src="js/fireball.js"></script>
    <script type="text/javascript" src="js/coin.js"></script>
    <script type="text/javascript" src="js/bcoin.js"></script>
    <script type="text/javascript" src="js/goomba.js"></script>
    <script type="text/javascript" src="js/koopa.js"></script>
    <script type="text/javascript" src="js/floor.js"></script>
    <script type="text/javascript" src="js/block.js"></script>
    <script type="text/javascript" src="js/rubble.js"></script>
    <script type="text/javascript" src="js/prop.js"></script>
    <script type="text/javascript" src="js/player.js"></script>
    <script type="text/javascript" src="js/flag.js"></script>
    <script type="text/javascript" src="js/levels/level.js"></script>
    <script type="text/javascript" src="js/levels/11tunnel.js"></script>




    <title>Generate Maps</title>
    <link href="images/mario.ico" rel="icon">
    <script>
        var numberOfMapsGenerated = 0;

        var choseGame;
        var gameName;

        var MdMC = true;
        var HMdMC = false;
        var MRF = false;

        var fileContent = [];
        var tileTypes = [];
        var hierTileTypes = [];
        var TopDown = false;
        var NumberMatrices = 0;
        var DependencyMatrices = [];
        var DepComplexities = [];
        var Hierarchical = false;
        var Rows = [];


        var Totals = [];
        var Probabilities = [];
        var HierTotals = [];
        var HierProbabilities = [];

        var TotalMatrix = [];
        var ProbMatrix = [];
        var HierTotalMatrix = [];
        var HierProbMatrix = [];
        var NumberOfRowSplits;

        var MapGen = [];
        var lookahead;

        var mapHeight;
        var mapWidth;

        var BackTracks;
        var badPipes;
        var NumberTilesWithEachMatrix = [];
        var start = 0;

        function GenerateTopLevelTile(PossibleTiles, h, w, offset, WhichDepMat, depth, method) {



            //PT.splice(2,1); remover from array

            var id = -1;
            var selector;

            var type = start;
            var PT = PossibleTiles;
            var Probs;


            while (PT.length > 0) {

                var ID = 0;
                var P = 0;

                //check if this state has been observed before
                for (var k = 0; k < 5; k++) {
                    for (var m = 0; m < 3; m++) {
                        if (DependencyMatrices[method][k][m] == 1) {
                            if (((h + (k - 2)) < 0) || ((h + (k - 2)) >= mapHeight) || ((w + (m - 2)) < 0))
                                type = start;
                            else {
                                for (var b = 0; b < tileTypes.length; b++) {
                                    if (MapGen[h + (k - 2)][w + (m - 2)] == tileTypes[b]) {
                                        type = b;
                                    }
                                }
                            }


                            ID += type * Math.pow(tileTypes.length, P);
                            P++;
                        }
                    }
                }

                var Obs = false;
                //check if the state has been observed before
                for (var a = 0; a < PT.length; a++) {
                    for (var x = 0; x < tileTypes.length; x++) {
                        if (PT[a] == tileTypes[x]) {

                            if (Probabilities[WhichDepMat][ID + Rows[WhichDepMat] * offset][x] != 0) {
                                Obs = true;
                                x = tileTypes.length;
                                a = PT.length;
                            }
                        }
                    }
                }

                if (Obs != true && depth != lookahead) { //if this state hasnt been observed and this is NOT the top level in the lookahead

                    BackTracks++; //then return an error
                    return 99;
                } else if (Obs != true && depth == lookahead) { //if we havent observed this state, and it IS the first step, then break out of
                    break; //of the loop, where we will return a random tile
                } else if (Obs == true) { //if we have observed this state, then generate the next tile


                    var Norm = 0;
                    Probs = [];
                    Probs.length = PT.length;

                    for (var i = 0; i < PT.length; i++) { //reset the value of Probs
                        Probs[i] = 0;
                    }




                    for (var a = 0; a < PT.length; a++) {
                        for (var x = 0; x < tileTypes.length; x++) {
                            if (PT[a] == tileTypes[x]) {
                                Probs[a] = Probabilities[WhichDepMat][ID + Rows[WhichDepMat] * offset][x];
                                Norm += Probabilities[WhichDepMat][ID + Rows[WhichDepMat] * offset][x];

                            }
                        }
                    }



                    for (var i = 0; i < PT.length; i++) { //renormalize the probabilities
                        Probs[i] = Probs[i] / Norm;
                    }



                    //PICK THE TILE
                    var PR = 0;
                    var tracker = 0;
                    selector = Math.random(); //2147483647  = RAND_MAX
                    //createNewParagraph(selector.toFixed(10));
                    for (var a = 0; a < PT.length; a++) {
                        PR = PR + Probs[a];

                        if (Probs[a] > 0) {
                            tracker = a;
                        }
                        if (selector <= PR) {

                            id = a;
                            break;
                        }
                        //if weirdness happens with the probabilities
                        //BROKEN
                        //if (a >= PT.size() - 1 && id == -1)
                        //  id = tracker;
                    }

                    if (h < MapGen.length && w < MapGen[0].length) {
                        MapGen[h][w] = PT[id];
                    }

                    //call the GenTile function to generate the next tile
                    //set to a test variable, so we can check the validity
                    //of the next state
                    var test = 1;



                    if (depth > 0) {

                        if (w < mapWidth - 1) {
                            test = GenerateTopLevelTile(tileTypes, h, w + 1, offset, WhichDepMat, depth - 1, method);

                        }
                    }

                    //if the next state isnt valid, remove the tile chosen in this state and try a different one
                    if (test == 99) {

                        var j = 0;
                        if (id < PT.length) {
                            for (var i = 0; i < PT.length; i++) {

                                if (PT[j] == PT[id]) {
                                    PT.splice(i, 1);
                                    break;
                                }
                                j++;
                            }

                        } else
                            PT = [];
                    } else {
                        for (var i = 0; i < tileTypes.length; i++) {
                            if (PT[id] == tileTypes[i])

                                return i;

                        }
                    }

                }
            }
            if (depth == lookahead) { //if no valid options on top level, return error code 100
                return 100;
            } else {
                BackTracks++;
                return 99; //if no valid options on sub level, return error.
            }
        }

        function GenerateTopLevel() {


            for (var i = 0; i < NumberMatrices; i++) {
                NumberTilesWithEachMatrix.push(0);
            }

            var PossibleTiles = [];
            PossibleTiles.length = tileTypes.length;


            for (var i = 1; i < tileTypes.length; i++) {
                PossibleTiles[i] = tileTypes[i];
            }

            MapGen.length = mapHeight;

            for (var i = 0; i < mapHeight; i++) {
                MapGen[i] = [];
                MapGen[i].length = mapWidth;
                for (var j = 0; j < mapWidth; j++) {
                    MapGen[i][j] = 'X';
                }
            }

            var rowsPerSplit = Math.floor(MapGen.length / NumberOfRowSplits);
            for (var h = MapGen.length - 1; h >= 0; h--) {
                var currRow = Math.floor(h / rowsPerSplit);
                if (currRow >= NumberOfRowSplits) {
                    currRow = NumberOfRowSplits - 1;
                }
                for (var j = 0; j < MapGen[h].length; j++) {
                    var id = GenerateTopLevelTile(PossibleTiles, h, j, currRow, 0, lookahead, 0); // CORRETO ATE AQUI

                    //if it fails, and we are using a fallback strategy, try to generate with the second config matrix
                    //if a good tile is generated with first method, track it
                    if (id != 100) {
                        NumberTilesWithEachMatrix[0]++;
                    }

                    var WhichDepMat = 1;
                    while (id == 100 && WhichDepMat < NumberMatrices) {

                        id = GenerateTopLevelTile(PossibleTiles, h, j, currRow, WhichDepMat, lookahead, WhichDepMat);
                        //track how many tiles generated with fallback method
                        if (id != 100) {
                            NumberTilesWithEachMatrix[WhichDepMat]++;
                            break;
                        } else {

                            WhichDepMat++;
                        }
                    }

                    //if it also fails, or we are not using a fallback strategy, generate a tile at random
                    if (id == 100) {
                        //ignore one of the tiles
                        while (id == 100 || (tileTypes == start)) {

                            var maximum = tileTypes.length - 1;
                            var minimum = 1;
                            id = Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;

                        }
                    }

                    MapGen[h][j] = tileTypes[id];

                }
            }

            var top = Math.floor(mapHeight * 0.15);
            var bottom = mapHeight - top;

            var char;
            var aux = "";
            for (var i = 0; i < MapGen.length; i++) {
                for (var j = 0; j < MapGen[i].length; j++) {
                    aux += MapGen[i][j];


                    char = MapGen[i][j];

                    if (gameName == "superMarioBros") {

                        if (i < MapGen.length - 1 && char == "#") {
                            createNewImage("mario", "#2");
                        } else if (char == "e") {
                            if (i + 1 < mapHeight) {
                                if (MapGen[i + 1][j] == "-") {
                                    createNewImage("mario", "EA");
                                } else {

                                    var chooseOne = Math.floor((Math.random() * 2) + 1);
                                    if (chooseOne == 1) {
                                        createNewImage("mario", "EF");
                                    } else {
                                        createNewImage("mario", "EF2");
                                    }

                                }
                            } else {
                                createNewImage("mario", "EF");
                            }

                        } else if (char == "p") {
                            if (i - 1 >= 0) {
                                if (MapGen[i - 1][j] != "p") {
                                    createNewImage("mario", "PT");
                                } else {
                                    createNewImage("mario", MapGen[i][j]);
                                }
                            } else {
                                createNewImage("mario", MapGen[i][j]);
                            }
                        } else if (char == "P") {
                            if (i - 1 >= 0) {
                                if (MapGen[i - 1][j] != "P") {
                                    createNewImage("mario", "PT2");
                                } else {
                                    createNewImage("mario", MapGen[i][j]);
                                }
                            } else {
                                createNewImage("mario", MapGen[i][j]);
                            }
                        } else {
                            createNewImage("mario", MapGen[i][j]);
                        }
                    } else if (gameName == "loderunner") {
                        createNewImage("loderunner", MapGen[i][j]);
                    } else if (gameName == "kidIcarus") {

                        if (char == "#") {
                            if (i > 0 && i > top) {
                                if (i - 1 >= 0) {
                                    if (MapGen[i - 1][j] != "#") {
                                        createNewImage("kidIcarus", "F2");
                                    } else {
                                        if (i <= top) {
                                            createNewImage("kidIcarus", "F3");
                                        } else {

                                            createNewImage("kidIcarus", MapGen[i][j]);
                                        }
                                    }
                                }
                            } else {
                                if (i <= top) {
                                    createNewImage("kidIcarus", "F3");
                                } else {

                                    createNewImage("kidIcarus", MapGen[i][j]);
                                }
                            }
                        } else if (char == "D") {

                            if (i <= top) {


                                if (i > 0) {
                                    if (i - 1 >= 0) {
                                        if (MapGen[i - 1][j] != "D") {
                                            createNewImage("kidIcarus", "DT2");
                                        } else {
                                            createNewImage("kidIcarus", "DT");
                                        }
                                    } else {
                                        createNewImage("kidIcarus", "DT");
                                    }
                                }

                            } else if (i >= bottom) {


                                if (i > 0) {
                                    if (i - 1 >= 0) {
                                        if (MapGen[i - 1][j] != "D") {
                                            createNewImage("kidIcarus", "DB2");
                                        } else {
                                            createNewImage("kidIcarus", "DB");
                                        }
                                    } else {
                                        createNewImage("kidIcarus", "DB");
                                    }
                                }

                            } else {


                                if (i > 0) {
                                    if (i - 1 >= 0) {
                                        if (MapGen[i - 1][j] != "D") {
                                            createNewImage("kidIcarus", "D2");
                                        } else {
                                            createNewImage("kidIcarus", MapGen[i][j]);
                                        }
                                    } else {
                                        createNewImage("kidIcarus", MapGen[i][j]);
                                    }
                                }
                            }




                        } else {
                            createNewImage("kidIcarus", MapGen[i][j]);
                        }
                    }


                    if (j == MapGen[i].length - 1) {
                        if (gameName != "other") {
                            createNewImage("space", "space");
                        }
                        createNewParagraph(aux, "textOutputTab");

                        if (gameName == "superMarioBros") {
                            createNewGame(aux);
                        }

                        aux = "";
                    }

                }
            }

            createNewParagraph("Map Number: " + numberOfMapsGenerated, "textOutputTab");
            createNewParagraph("Height: " + mapHeight + " - Width: " + mapWidth + " - Row Splits: " + NumberOfRowSplits + " - Network Structure: " + document.getElementById("networkStructure").value, "textOutputTab");
            createNewParagraph("[End]", "textOutputTab");

            createNewParagraph("Map Number: " + numberOfMapsGenerated, "graphicOutputTab");
            createNewParagraph("Height: " + mapHeight + " - Width: " + mapWidth + " - Row Splits: " + NumberOfRowSplits + " - Network Structure: " + document.getElementById("networkStructure").value, "graphicOutputTab");
            createNewParagraph("[End]", "graphicOutputTab");


            //-------------- CLEAR VARIABLES ----------------------

            choseGame = null;
            gameName = null;

            fileContent = [];
            tileTypes = [];
            hierTileTypes = [];
            TopDown = false;
            NumberMatrices = 0;
            DependencyMatrices = [];
            DepComplexities = [];
            Hierarchical = false;
            Rows = [];


            Totals = [];
            Probabilities = [];
            HierTotals = [];
            HierProbabilities = [];

            TotalMatrix = [];
            ProbMatrix = [];
            HierTotalMatrix = [];
            HierProbMatrix = [];
            NumberOfRowSplits;

            MapGen = [];
            lookahead = null;

            mapHeight = null;
            mapWidth = null;

            BackTracks = null;
            badPipes = null;
            NumberTilesWithEachMatrix = [];
            start = 0;

            var samplingMapsButton = document.getElementById("samplingMapsButton");
            samplingMapsButton.disabled = true;

        }

        function SetProbsForOnlyLowLevel(WhichDepMat) {

            var P = 0;
            var index = 0;
            var Types = 0;
            var i = 0;


            if (Hierarchical) {
                Types = hierTileTypes.length;
            } else {
                Types = tileTypes.length;
            }

            var TotalsFile = ProbMatrix[WhichDepMat][0].length * ProbMatrix[WhichDepMat][0][0].length;

            if (Hierarchical == false) {
                Probabilities[WhichDepMat] = [];
                var Tmp = [];

                while (i < TotalsFile * NumberOfRowSplits) {
                    Tmp.push(P);
                    i++;
                    index++;
                    if (index == Types) {
                        index = 0;
                        Probabilities[WhichDepMat].push(Tmp);
                        Tmp = [];
                    }
                }
                //createNewParagraph(Probabilities[WhichDepMat].length);
            } else {
                var Tmp = [];
                HierProbabilities = [];
                var TMP = [];
                var innerIndex = 0;
                var i = 0;
                var TotalsFile = ProbMatrix[WhichDepMat][0].length * ProbMatrix[WhichDepMat][0][0].length;
                while (i < TotalsFile * NumberOfRowSplits) {
                    Tmp.push(P);
                    i++;
                    index++;
                    if (index == Types) {
                        index = 0;
                        TMP.push(Tmp);
                        Tmp = [];
                        innerIndex++;
                        if (innerIndex == Rows[WhichDepMat]) {
                            innerIndex = 0;
                            HierProbabilities[WhichDepMat].push(TMP);
                            TMP = [];
                        }
                    }
                }
            }

            if (Hierarchical) {

                // ------------ NEED TO FIX FOR HIERARCHICAL ------------------ VVVVVVVVVVVVVVVVVVVVVVVVVVVV ----------- XXXXX
                for (var k = 0; k < hierTileTypes.length; k++) {
                    for (var i = 0; i < Rows[WhichDepMat]; i++) {
                        if (HierTotals[WhichDepMat][k][i][Types] == 0)
                            HierTotals[WhichDepMat][k][i][Types]++; //if total=0, add 1 to prevent division by 0
                        for (var j = 0; j < Types; j++) {
                            HierProbabilities[WhichDepMat][k][i][j] = HierTotals[WhichDepMat][k][i][j] / HierTotals[WhichDepMat][k][i][Types];
                        }
                    }
                }

            } else {


                for (var i = 0; i < Totals[WhichDepMat].length; i++) {
                    for (var j = 0; j < Totals[WhichDepMat][0].length - 1; j++) {
                        //if there is a 0 in the totals column, replace it with a one to avoid div. by 0
                        if (Totals[WhichDepMat][i][Types] == 0) {
                            Totals[WhichDepMat][i][Types]++;
                        }

                        Probabilities[WhichDepMat][i][j] = Totals[WhichDepMat][i][j] / Totals[WhichDepMat][i][Types];
                    }
                }
            }

            /*
            createNewParagraph("P-----------------------------------------------","textOutputTab");
            for(var i = 0; i < Probabilities[WhichDepMat].length; i++){ // SHOW PROPABILITIES MATRICES IN THE TEXT OUTPUT
               createNewParagraph(Probabilities[WhichDepMat][i],"textOutputTab");
            }
            createNewParagraph("P-----------------------------------------------","textOutputTab");
            */

        }



        function SetTotalsTopLevel(WhichDepMat, numberOfTrainingMaps) {


            var numTypes = -1;
            var start = 0;
            var tilesVec = [];

            if (Hierarchical) {
                numTypes = hierTileTypes.length;
                for (var i = 0; i < numTypes; i++) {
                    tilesVec.push(hierTileTypes[i]);
                }
            } else {
                numTypes = tileTypes.length;
                for (var i = 0; i < numTypes; i++) {
                    tilesVec.push(tileTypes[i]);
                }
            }

            var TotalsFile = TotalMatrix[WhichDepMat][0].length * TotalMatrix[WhichDepMat][0][0].length;



            if (Totals[WhichDepMat] == null) {
                Totals[WhichDepMat] = [];
                var T = 0;
                var index = 0;
                var i = 0;
                var Tmp = [];

                while (i < TotalsFile * NumberOfRowSplits) { // size of Total MATRIX
                    Tmp.push(T);
                    i++;
                    index++;
                    if (index == numTypes + 1) {
                        index = 0;
                        Totals[WhichDepMat].push(Tmp);
                        Tmp = [];
                    }
                }
            }



            var MapVec = [];
            var TempVec = [];
            var InputMapSize;
            var line = "";
            var m;
            var aux = '';
            var indexTemp = 0;


            for (var maps = 0; maps < numberOfTrainingMaps; maps++) {
                InputMapSize = fileContent[maps].length;
                MapVec.push([]); // Vetor inteiro



                for (m = 0; m < InputMapSize; m++) {
                    var char = fileContent[maps][m];

                    if (char == '\n' || char == '\t') {


                        MapVec[0].push(TempVec); //parte de vetores
                        indexTemp = 0;
                        TempVec = [];



                    } else {
                        TempVec[indexTemp] = char;
                        indexTemp++;
                    }
                }



                var ID;
                var P;
                var id;
                var rowsPerSplit = Math.floor(MapVec[0].length / NumberOfRowSplits);


                if (rowsPerSplit == 0) {
                    rowsPerSplit = 1;
                }


                for (var h = MapVec[0].length - 1; h >= 0; h--) {
                    //alert(Math.floor(h/(Math.floor(MapVec[maps].length / 5))))

                    var currRow = Math.floor(h / rowsPerSplit);

                    if (currRow >= NumberOfRowSplits) {
                        currRow = NumberOfRowSplits - 1;
                    }



                    for (var w = 0; w < MapVec[0][h].length; w++) {


                        ID = 0;

                        P = 0;

                        for (var i = 0; i < DependencyMatrices[WhichDepMat].length; i++) {
                            id = 0;

                            for (var j = 0; j < DependencyMatrices[WhichDepMat][i].length; j++) {


                                if (DependencyMatrices[WhichDepMat][i][j] == 1) {


                                    if (((h + (i - 2)) < 0) || ((h + (i - 2)) >= MapVec[0].length) || ((w + (j - 2)) < 0)) {

                                        id = start;

                                    } else {

                                        for (var m = 0; m < numTypes; m++) {

                                            if (tilesVec[m] == MapVec[0][h + (i - 2)][w + (j - 2)]) {
                                                id = m;
                                                break;
                                            }
                                        }
                                    }
                                    ID += id * Math.pow(numTypes, P);
                                    P++;
                                }

                            }
                        }


                        for (var m = 0; m < numTypes; m++) {
                            if (tilesVec[m] == MapVec[0][h][w]) {

                                id = m;
                                break;
                            }
                        }


                        //createNewParagraph(ID);

                        Totals[WhichDepMat][ID + Rows[WhichDepMat] * currRow][id]++;

                        Totals[WhichDepMat][ID + Rows[WhichDepMat] * currRow][numTypes]++;


                    }

                }
                MapVec = [];

            }
            /*
            createNewParagraph(tilesVec, "textOutputTab");

            createNewParagraph("T---------------------------------------------------------","textOutputTab");
                for(var i = 0; i < Totals[WhichDepMat].length; i++){  //SHOW TOTALS MATRICES IN TEXT OUTPUT

                    createNewParagraph(Totals[WhichDepMat][i],"textOutputTab");

                }

                createNewParagraph("T---------------------------------------------------------","textOutputTab");
                */

        }

        function InitFiles(WhichDepMat) {


            TotalMatrix.push([]);
            ProbMatrix.push([]);

            HierTotalMatrix.push([]);
            HierProbMatrix.push([]);

            if (Hierarchical == false)
                for (var k = 0; k < NumberOfRowSplits; k++) {

                    TotalMatrix[WhichDepMat].push([]);
                    ProbMatrix[WhichDepMat].push([]);

                    for (var i = 0; i < Rows[WhichDepMat]; i++) {

                        TotalMatrix[WhichDepMat][k].push([]);
                        ProbMatrix[WhichDepMat][k].push([]);

                        for (var j = 0; j <= tileTypes.length; j++) {
                            if (j < tileTypes.length) {
                                ProbMatrix[WhichDepMat][k][i].push(0);
                            }
                            TotalMatrix[WhichDepMat][k][i].push(0);
                        }
                    }
                } else {
                    for (var k = 0; k < NumberOfRowSplits; k++) {

                        HierTotalMatrix[WhichDepMat].push([]);
                        HierProbMatrix[WhichDepMat].push([]);

                        for (var i = 0; i < Rows[WhichDepMat]; i++) {

                            HierTotalMatrix[WhichDepMat][k].push([]);
                            HierProbMatrix[WhichDepMat][k].push([]);

                            for (var j = 0; j <= hierTileTypes.length; j++) {
                                if (j < hierTileTypes.length) {
                                    HierProbMatrix[WhichDepMat][k][i].push(0);
                                }
                                HierTotalMatrix[WhichDepMat][k][i].push(0);
                            }
                        }
                    }
                }


            //createNewParagraph(TotalMatrix.length,"textOutputTab");

        }

        function SetRows() {
            var types = 0;

            if (Hierarchical == true) {
                types = hierTileTypes.length;
            } else {
                types = tileTypes.length;
            }

            for (var i = 0; i < NumberMatrices; i++) {
                Rows.push(1);
                for (var j = 0; j < DepComplexities[i]; j++)
                    Rows[i] *= types;

            }

            //document.getElementById("textOutputTab").innerHTML = Rows;
        }

        function SetDepMatrix(DepMatrix) {

            var TempDepMat = [
                [],
                [],
                [],
                [],
                []
            ];
            for (var i = 0; i < 5; i++)
                TempDepMat[i].length = 3;

            for (var i = 0; i < 5; i++) { //initialize array to all 0's
                for (var j = 0; j < 3; j++)
                    TempDepMat[i][j] = 0;
            }
            TempDepMat[2][2] = 2; //block we are finding the probability for

            if (TopDown) { //if we are generating from the top down...
                if (DepMatrix == 1) //use the previous block to determine probability
                    TempDepMat[2][1] = 1;
                else if (DepMatrix == 2) { //use the previous block and the block above to determine probability
                    TempDepMat[2][1] = 1; //previous
                    TempDepMat[1][2] = 1; //above
                } else if (DepMatrix == 3) { //use previous block, and previous above block, and above block to determine probability
                    TempDepMat[2][1] = 1; //previous
                    TempDepMat[1][1] = 1; //previous above
                    TempDepMat[1][2] = 1; //above
                }
            } else { //if we are generating from the bottom up

                if (DepMatrix == 1) //only use the previous block to determine probability
                    TempDepMat[2][1] = 1;
                else if (DepMatrix == 2) { //use the previous block and the block below to determine probability
                    TempDepMat[2][1] = 1; //previous
                    TempDepMat[3][2] = 1; //below
                } else if (DepMatrix == 3) { //use previous block, and previous below block, and below block to determine probability
                    TempDepMat[2][1] = 1; //previous
                    TempDepMat[3][1] = 1; //previous below
                    TempDepMat[3][2] = 1; //below
                }
            }

            NumberMatrices++;
            DependencyMatrices.push(TempDepMat);




            if (DepMatrix == 0)
                DepComplexities.push(0);
            else if (DepMatrix == 1)
                DepComplexities.push(1);
            else if (DepMatrix == 2)
                DepComplexities.push(2);
            else if (DepMatrix == 3)
                DepComplexities.push(3);



        }

        function FindTilesTypes(fileNumber) {
            var strLength = fileContent[fileNumber].length;
            var c;


            if (Hierarchical == false) {
                if (tileTypes.indexOf('S') == -1) {
                    tileTypes.push('S');
                }

                for (var i = 0; i < strLength; i++) {
                    c = fileContent[fileNumber][i];
                    if (tileTypes.indexOf(c) == -1 && c != '\n' && c != '\t' && c != '\r') {
                        tileTypes.push(c);
                    }
                }


            } else {
                if (hierTileTypes.indexOf('S') == -1) {
                    hierTileTypes.push('S');
                }

                for (var i = 0; i < strLength; i++) {
                    c = fileContent[fileNumber][i];
                    if (hierTileTypes.indexOf(c) == -1 && c != '\n' && c != '\t' && c != '\r') {
                        hierTileTypes.push(c);
                    }
                }

            }

            //createNewParagraph(tileTypes,"textOutputTab");

        }

        function samplesGenerated() {
            var ready = true;
            var count = 0;
            var rowSplits = document.getElementById("rowSplits").value;

            for (var i = 0; i < fileContent.length; i++) {
                for (var j = 0; j < fileContent[i].length; j++) {
                    if (fileContent[i][j] == '\n' || fileContent[i][j] == '\t') {
                        count++;
                    }
                }

                if (fileContent[i][fileContent[i].length - 1] != '\n' || fileContent[i][fileContent[i].length - 1] != '\t') {
                    count++;
                    fileContent[i] += '\n';
                }

                if (rowSplits > count) {
                    ready = false;
                    alert("Number of Row Splits exceeds the number of provided map's rows!\nActual Row Splits: " + rowSplits + ".\nMap's rows: " + count + ".");
                    document.getElementById("rowSplits").value = count;
                } else {
                    count = 0;
                }

            }


            if (ready) {
                numberOfMapsGenerated++;



                //alert(fileContent);
                //tileTypes.indexOf("a");


                var networkStructure = document.getElementById("networkStructure").value;

                Hierarchical = HMdMC;

                NumberOfRowSplits = document.getElementById("rowSplits").value;

                for (var i = 0; i < fileContent.length; i++) {
                    FindTilesTypes(i);
                }


                for (var i = networkStructure; i >= 0; i--) {
                    SetDepMatrix(i);
                }


                SetRows();
                ResizeVectors();



                for (var i = 0; i < NumberMatrices; i++) {
                    InitFiles(i);
                }



                for (var dep = 0; dep < NumberMatrices; dep++) {
                    SetTotalsTopLevel(dep, fileContent.length) //depth, trainingMaps
                }

                for (var dep = 0; dep < NumberMatrices; dep++) {
                    SetProbsForOnlyLowLevel(dep) //depth
                }


                GenerateTopLevel();


            }

        }

        function createNewParagraph(string, element) {
            var text = string;
            var newParagraph = document.createElement('p');
            newParagraph.textContent = text;
            document.getElementById(element).appendChild(newParagraph);
        }

        function createNewImage(game, tile) {

            var img = document.createElement("img");
            if (tile == "space") {
                var newParagraph = document.createElement('div');
                newParagraph.id = "space";
                document.getElementById("graphicOutputTab").appendChild(newParagraph);
            }

            if (game == "mario") {


                if (tile == "#") {
                    img.src = "Images_Mario/G.png";
                } else if (tile == "p") {
                    img.src = "Images_Mario/P.png";
                } else if (tile == "P") {
                    img.src = "Images_Mario/P2.png";
                } else if (tile == "B") {
                    img.src = "Images_Mario/B.png";
                } else if (tile == "?") {
                    img.src = "Images_Mario/B2.png";
                } else if (tile == "#2") {
                    img.src = "Images_Mario/G2.png";
                } else if (tile == "-") {
                    img.src = "Images_Mario/E.png";
                } else if (tile == "PT") {
                    img.src = "Images_Mario/PT.png";
                } else if (tile == "PT2") {
                    img.src = "Images_Mario/PT2.png";
                } else if (tile == "c") {
                    img.src = "Images_Mario/C.png";
                } else if (tile == "EF") {
                    img.src = "Images_Mario/EF.png";
                } else if (tile == "EA") {
                    img.src = "Images_Mario/EA.png";
                } else if (tile == "EF2") {
                    img.src = "Images_Mario/EF2.png";
                } else {
                    img.src = "Images_Mario/E.png";
                }

            } else if (game == "loderunner") {


                if (tile == "b") {
                    img.src = "Images_Loderunner/F.png";
                } else if (tile == "#") {
                    img.src = "Images_Loderunner/L.png";
                } else if (tile == "G") {
                    img.src = "Images_Loderunner/G.png";
                } else if (tile == "E") {
                    img.src = "Images_Loderunner/EN.png";
                } else if (tile == "-") {
                    img.src = "Images_Loderunner/R.png";
                } else if (tile == ".") {
                    img.src = "Images_Loderunner/E.png";
                } else if (tile == "B") {
                    img.src = "Images_Loderunner/B.png";
                } else {
                    img.src = "Images_Loderunner/E.png";
                }
            } else if (game == "kidIcarus") {
                if (tile == "D") {
                    img.src = "Images_Kid_Icarus/D.png";
                } else if (tile == "D2") {
                    img.src = "Images_Kid_Icarus/D2.png";
                } else if (tile == "DB") {
                    img.src = "Images_Kid_Icarus/DB.png";
                } else if (tile == "DB2") {
                    img.src = "Images_Kid_Icarus/DB2.png";
                } else if (tile == "DT") {
                    img.src = "Images_Kid_Icarus/DT.png";
                } else if (tile == "DT2") {
                    img.src = "Images_Kid_Icarus/DT2.png";
                } else if (tile == "-") {
                    img.src = "Images_Kid_Icarus/E.png";
                } else if (tile == "#") {
                    img.src = "Images_Kid_Icarus/F.png";
                } else if (tile == "F2") {
                    img.src = "Images_Kid_Icarus/F2.png";
                } else if (tile == "F3") {
                    img.src = "Images_Kid_Icarus/F3.png";
                } else if (tile == "T") {
                    img.src = "Images_Kid_Icarus/P.png";
                } else {
                    img.src = "Images_Kid_Icarus/E.png";
                }
            }

            img.id = "picture";
            var foo = document.getElementById("graphicOutputTab");
            foo.appendChild(img);
        }

        var mapData = "";
        var mapDataSize = 0;
        var oldMapData = "";
        function createNewGame(string) {
            mapDataSize++;
            mapData += string + "\n";

            if (mapDataSize == mapHeight) {

                // Clearing mapData so user can always be playing the most recently generated map
                // (as opposed to the first generated map)
                oldMapData = JSON.parse(JSON.stringify(mapData))
                mapData = "";
                mapDataSize = 0;

                var oneone = Mario.oneone = function() {
                    //The things that need to be passed in are basically just dependent on what
                    //tileset we're in, so it makes more sense to just make one variable for that, so
                    //TODO: put as much of this in the Level object definition as possible.
                    level = new Mario.Level({
                        playerPos: [56, 192],
                        loader: Mario.oneone,
                        background: "#7974FF",
                        scrolling: true,
                        invincibility: [144, 192, 240],
                        exit: 204,
                        floorSprite: new Mario.Sprite('sprites/tiles.png', [0, 0], [16, 16], 0),
                        cloudSprite: new Mario.Sprite('sprites/tiles.png', [0, 320], [48, 32], 0),
                        wallSprite: new Mario.Sprite('sprites/tiles.png', [0, 16], [16, 16], 0),
                        brickSprite: new Mario.Sprite('sprites/tiles.png', [16, 0], [16, 16], 0),
                        brickBounceSprite: new Mario.Sprite('sprites/tiles.png', [32, 0], [16, 16], 0),
                        rubbleSprite: function() {
                            return new Mario.Sprite('sprites/items.png', [64, 0], [8, 8], 3, [0, 1])
                        },
                        ublockSprite: new Mario.Sprite('sprites/tiles.png', [48, 0], [16, 16], 0),
                        superShroomSprite: new Mario.Sprite('sprites/items.png', [0, 0], [16, 16], 0),
                        fireFlowerSprite: new Mario.Sprite('sprites/items.png', [0, 32], [16, 16], 20, [0, 1, 2, 3]),
                        starSprite: new Mario.Sprite('sprites/items.png', [0, 48], [16, 16], 20, [0, 1, 2, 3]),
                        pipeLEndSprite: new Mario.Sprite('sprites/tiles.png', [0, 128], [16, 16], 0),
                        pipeREndSprite: new Mario.Sprite('sprites/tiles.png', [16, 128], [16, 16], 0),
                        pipeLMidSprite: new Mario.Sprite('sprites/tiles.png', [0, 144], [16, 16], 0),
                        pipeRMidSprite: new Mario.Sprite('sprites/tiles.png', [16, 144], [16, 16], 0),

                        pipeUpMid: new Mario.Sprite('sprites/tiles.png', [0, 144], [32, 16], 0),
                        pipeSideMid: new Mario.Sprite('sprites/tiles.png', [48, 128], [16, 32], 0),
                        pipeLeft: new Mario.Sprite('sprites/tiles.png', [32, 128], [16, 32], 0),
                        pipeTop: new Mario.Sprite('sprites/tiles.png', [0, 128], [32, 16], 0),
                        qblockSprite: new Mario.Sprite('sprites/tiles.png', [384, 0], [16, 16], 8, [0, 0, 0, 0, 1, 2, 1]),
                        bcoinSprite: function() {
                            return new Mario.Sprite('sprites/items.png', [0, 112], [16, 16], 20, [0, 1, 2, 3]);
                        },
                        cloudSprites: [
                            new Mario.Sprite('sprites/tiles.png', [0, 320], [16, 32], 0),
                            new Mario.Sprite('sprites/tiles.png', [16, 320], [16, 32], 0),
                            new Mario.Sprite('sprites/tiles.png', [32, 320], [16, 32], 0)
                        ],
                        hillSprites: [
                            new Mario.Sprite('sprites/tiles.png', [128, 128], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [144, 128], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [160, 128], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [128, 144], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [144, 144], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [160, 144], [16, 16], 0)
                        ],
                        bushSprite: new Mario.Sprite('sprites/tiles.png', [176, 144], [48, 16], 0),
                        bushSprites: [
                            new Mario.Sprite('sprites/tiles.png', [176, 144], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [192, 144], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [208, 144], [16, 16], 0)
                        ],
                        goombaSprite: function() {
                            return new Mario.Sprite('sprites/enemy.png', [0, 16], [16, 16], 3, [0, 1]);
                        },
                        koopaSprite: function() {
                            return new Mario.Sprite('sprites/enemy.png', [96, 0], [16, 32], 2, [0, 1]);
                        },
                        flagPoleSprites: [
                            new Mario.Sprite('sprites/tiles.png', [256, 128], [16, 16], 0),
                            new Mario.Sprite('sprites/tiles.png', [256, 144], [16, 16], 0),
                            new Mario.Sprite('sprites/items.png', [128, 32], [16, 16], 0)
                        ]
                    });

                    player.pos[0] = level.playerPos[0];
                    player.pos[1] = level.playerPos[1];
                    vX = 0;

                    //interactable terrain
                    var lines = oldMapData.split("\n");

                    // Checking initial viability.
                    // Pretty much just seeing if the Player will be killed before they move.
                    // We need to check a larger region for enemies since they move
                    for (var r = 0; r < lines.length; r++) {
                        for (var c = 0; c < 17; c++) {
                            if (lines[r].charAt(c) == "e") {
                                lines[r] = lines[r].substring(0, c) + "-" + lines[r].substring(c + 1, lines[r].length);
                            }
                        }
                    }
                    // Just making sure Mario doesn't suffocate
                    for (var r = 9; r < 12; r++) {
                        for (var c = 3; c < 5; c++) {
                            var currChar = lines[r].charAt(c);
                            if (currChar == "#" || currChar == "B") {
                                lines[r] = lines[r].substring(0, c) + "-" + lines[r].substring(c + 1, lines[r].length);
                            } else if (currChar == "p") {
                                lines[r] = lines[r].substring(0, c) + "--" + lines[r].substring(c + 2, lines[r].length);
                            } else if (currChar == "P") {
                                lines[r] = lines[r].substring(0, c - 2) + "--" + lines[r].substring(c, lines[r].length);
                            }
                        }
                    }
                    // Making sure there's a floor beneath Mario
                    for (var c =3; c < 5; c++) {
                        var currChar = lines[lines.length - 2].charAt(c);
                        if (currChar == "-") {
                            lines[lines.length - 2] = lines[lines.length - 2].substring(0, c) + "#" + lines[lines.length - 2].substring(c + 1, lines[lines.length - 2].length);
                        }
                    }

                    // Adding bricks, enemies, etc.
                    for (var r = 0; r < lines.length - 2; r++) {
                        for (var c = 0; c < lines[r].length; c++) {
                            var currChar = lines[r].charAt(c);
                            if (currChar == "B") {
                                level.putBrick(c, r + 2, null); // Not sure why this is reversed...
                            } else if (currChar == "?") {
                                level.putQBlock(c, r + 2, new Mario.Bcoin([c * 16, (r + 2) * 16]));
                            } else if (currChar == "#") {
                                level.putWall(c, r + 3, 1);
                            } else if (currChar == "p" && lines[r + 1].charAt(c) == "#") { // bottom left of pipe
                                var pipeHeight = 0;
                                for (var r1 = r; r1 >= 0; r1--) {
                                    if (lines[r1].charAt(c) != "p") {
                                        break;
                                    }
                                    pipeHeight++;
                                }
                                level.putPipe(c, r + 3, pipeHeight);
                            } else if (currChar == "e") {
                                // Two Goombas just spawn at (3, 2) and (7, 2) no matter what.
                                // I even switched the entire Mario game for a new one...
                                if (r != 0 || r != 00 && (c != 3 || c != 7)) {
                                    level.putGoomba(c, r + 2);
                                }
                            }
                        }
                    }

                    // Floor
                    var floors = new Array();
                    var indivFloor = new Array();
                    for (var c = 0; c < lines[lines.length - 2].length; c++) {
                        if (indivFloor.length == 0 && lines[lines.length - 2].charAt(c) == "#") {
                            indivFloor.push(c);
                        } else if (lines[lines.length - 2].charAt(c) == "-" && indivFloor.length == 1) {
                            indivFloor.push(c - 1);
                            floors.push(indivFloor);
                            indivFloor = new Array();
                        }
                    }
                    indivFloor.push(lines[lines.length - 2].length);
                    floors.push(indivFloor);

                    floors.forEach(function(loc) {
                        level.putFloor(loc[0],loc[1]);
                    });

                    // Flagpole makes me feel satisfied. 7 is arbitrary.
                    level.putFlagpole(lines[lines.length - 2].length - 7);

                    music.underground.pause();
                    // music.overworld.currentTime = 0;
                    music.overworld.play();
                };


                document.getElementById("playMario").onclick = function() {
                    var script = document.createElement("script");
                    script.src = "js/game.js";
                    document.head.appendChild(script);

                    Mario.oneone();

                    document.getElementById("gameOutputTab").innerHTML = "";

                    document.getElementById("playMario").onclick = function() {
                    };
                }
                document.getElementById("playMario").style.cursor = "default";

                document.getElementById("options").addEventListener("click", pauseMario, false);
                document.getElementById("textOutput").addEventListener("click", pauseMario, false);
                document.getElementById("graphicOutput").addEventListener("click", pauseMario, false);

                function pauseMario() {
                    // TODO: Mute ALL sounds.
                    music.overworld.pause();
                }
            }
        }


        function changeTrainingMaps() {
            var x = document.getElementById("fileinput");
            if (x.disabled == true) {
                x.disabled = false;
            } else {
                x.disabled = true;
            }
        }

        function samplingReady() {
            var userYourOwnMapsRadio = document.getElementById("userYourOwnMapsRadio");
            tileTypes = [];

            var ready = true;
            var width = document.getElementById("width").value;
            var height = document.getElementById("height").value;
            var rowSplits = document.getElementById("rowSplits").value;
            var networkStructure = document.getElementById("networkStructure").value;

            if (width > 300) {
                ready = false;
                alert("Max Width: 300!");
                document.getElementById("width").value = 300;
            }
            if (width < 12) {
                ready = false;
                alert("Min Width: 12!");
                document.getElementById("width").value = 12;
            }
            if (height > 200) {
                ready = false;
                alert("Max Height: 200!");
                document.getElementById("height").value = 200;
            }
            if (height < 12) {
                ready = false;
                alert("Min Height: 12!");
                document.getElementById("height").value = 12;
            }

            if (rowSplits < 1) {
                ready = false;
                alert("Min Number of Row Splits: 1!");
                document.getElementById("rowSplits").value = 1;
            }
            if (networkStructure > 3) {
                ready = false;
                alert("Max Network Structure: 3!");
                document.getElementById("networkStructure").value = 3;
            }
            if (networkStructure < 0) {
                ready = false;
                alert("Min Network Structure: 0!");
                document.getElementById("networkStructure").value = 0;
            }


            if (ready) {
                var file = document.getElementById("fileinput").files[0];
                if (file && userYourOwnMapsRadio.checked == true || userYourOwnMapsRadio.checked == false) {
                    var samplingMapsButton = document.getElementById("samplingMapsButton");
                    samplingMapsButton.disabled = false;
                    MdMCExperiments();
                } else {
                    alert("Please choose Training Maps!");
                }
            }
        }




        function ResizeVectors() {

            Totals.length = NumberMatrices;
            Probabilities.length = NumberMatrices;
            if (Hierarchical) {
                HierTotals.length = NumberMatrices;
                HierProbabilities.length = NumberMatrices;
            }
        }


        function MdMCExperiments() {

            gameName = document.getElementById("formChooseAGame").value;
            var trainingFolderNameValue = document.getElementById("fileinput").value;
            var rowSplitsValue = document.getElementById("rowSplits").value;
            var lookaheadValue = document.getElementById("lookahead").value;
            var networkStructureValue = "2";
            var trainingMapsValue = "10";
            var toGenerateValue = "100";
            var heightValue = document.getElementById("height").value;
            var widthValue = document.getElementById("width").value;
            var userYourOwnMapsRadio = document.getElementById("userYourOwnMapsRadio");
            lookahead = document.getElementById("lookahead").value;
            mapHeight = document.getElementById("height").value;
            mapWidth = document.getElementById("width").value;

            fileContent = [];

            if (userYourOwnMapsRadio.checked == false) {


                if (gameName == "kidIcarus") {
                    for (var i = 1; i <= 6; i++) {
                        jQuery.get('KidIcarus_Maps/kidicarus_' + i + '.txt', function(data) {
                            fileContent.push(data);
                        });
                    }
                } else if (gameName == "loderunner") {
                    for (var i = 1; i <= 150; i++) {
                        jQuery.get('Loderunner_Maps/Level ' + i + '.txt', function(data) {
                            fileContent.push(data);
                        });
                    }
                } else if (gameName == "superMarioBros") {
                    for (var i = 1; i <= 1; i++) {
                        jQuery.get('Mario_Maps/mario_' + i + '.txt', function(data) {
                            fileContent.push(data);

                        });
                    }
                }
                //'Mario_Maps/mario_'+i+'.txt'




                //CAPTAR LETRAS

            } else {

                var file = document.getElementById("fileinput").files[0];

                if (file) {
                    var reader = new FileReader();
                    reader.readAsText(file, "UTF-8");
                    reader.onload = function(evt) {
                        fileContent[0] = evt.target.result;

                    }
                    reader.onerror = function(evt) {
                        fileContent[0] = "Fail to Load File!"
                    }

                }

            }

        }

        //--------------------- SITE FUNCTIONS -------------------------------------------

        function gameChanged(selectedValue) {

            numberOfMapsGenerated = 0;

            choseGame = selectedValue;
            if (selectedValue == "other") {
                document.getElementById("defaultMaps").disabled = true;
                document.getElementById("userYourOwnMapsRadio").checked = true;
                document.getElementById("fileinput").disabled = false;
            } else {
                document.getElementById("defaultMaps").disabled = false;

            }


            if (selectedValue == "loderunner") {
                $('#textOutputTab').empty();
                $('#graphicOutputTab').empty();
                document.getElementById("rowSplits").value = 22;
                document.getElementById("height").value = 22;
                document.getElementById("width").value = 32;
                document.getElementById("networkStructure").value = 3;
            } else if (selectedValue == "superMarioBros") {
                $('#textOutputTab').empty();
                $('#graphicOutputTab').empty();
                document.getElementById("rowSplits").value = 12;
                document.getElementById("height").value = 12;
                document.getElementById("width").value = 210;
                document.getElementById("networkStructure").value = 3;
            } else if (selectedValue == "kidIcarus") {
                $('#textOutputTab').empty();
                $('#graphicOutputTab').empty();
                document.getElementById("rowSplits").value = 159;
                document.getElementById("height").value = 159;
                document.getElementById("width").value = 16;
                document.getElementById("networkStructure").value = 3;
            }
        }

        function changeToMRF() {
            var rowSplits = document.getElementById("rowSplits");
            var lookahead = document.getElementById("lookahead");
            var numberOfClusters = document.getElementById("numberOfClusters");
            var distanceMetric = document.getElementById("distanceMetric");
            var tileSize = document.getElementById("tileSize");
            var manualRadio = document.getElementById("manualRadio");
            var parameters = document.getElementById("parameters");
            var clusteringBasedRadio = document.getElementById("clusteringBasedRadio");
            var formHighLevelConvertion = document.getElementById("formHighLevelConvertion");
            var newworkStructure = document.getElementById("networkStructure");

            rowSplits.disabled = true;
            lookahead.disabled = true;
            numberOfClusters.disabled = true;
            distanceMetric.disabled = true;
            tileSize.disabled = true;
            manualRadio.disabled = true;
            parameters.disabled = true;
            clusteringBasedRadio.disabled = true;
            formHighLevelConvertion.disabled = true;
            networkStructure.disabled = true;

            MdMC = false;
            HMdMC = false;
            MRF = true;

        }

        function changeToMdMC() {
            var rowSplits = document.getElementById("rowSplits");
            var lookahead = document.getElementById("lookahead");
            var numberOfClusters = document.getElementById("numberOfClusters");
            var distanceMetric = document.getElementById("distanceMetric");
            var tileSize = document.getElementById("tileSize");
            var manualRadio = document.getElementById("manualRadio");
            var parameters = document.getElementById("parameters");
            var clusteringBasedRadio = document.getElementById("clusteringBasedRadio");
            var formHighLevelConvertion = document.getElementById("formHighLevelConvertion");
            var networkStructure = document.getElementById("networkStructure");

            rowSplits.disabled = false;
            lookahead.disabled = true;
            numberOfClusters.disabled = true;
            distanceMetric.disabled = true;
            tileSize.disabled = true;
            manualRadio.disabled = true;
            parameters.disabled = true;
            clusteringBasedRadio.disabled = true;
            formHighLevelConvertion.disabled = true;
            networkStructure.disabled = false;

            MdMC = true;
            HMdMC = false;
            MRF = false;

        }

        function changeToHMdMC() {
            var rowSplits = document.getElementById("rowSplits");
            var lookahead = document.getElementById("lookahead");
            var numberOfClusters = document.getElementById("numberOfClusters");
            var distanceMetric = document.getElementById("distanceMetric");
            var tileSize = document.getElementById("tileSize");
            var manualRadio = document.getElementById("manualRadio");
            var parameters = document.getElementById("parameters");
            var clusteringBasedRadio = document.getElementById("clusteringBasedRadio");
            var formHighLevelConvertion = document.getElementById("formHighLevelConvertion");
            var networkStructure = document.getElementById("networkStructure");

            rowSplits.disabled = false;
            lookahead.disabled = true;
            numberOfClusters.disabled = false;
            distanceMetric.disabled = false;
            tileSize.disabled = false;
            manualRadio.disabled = false;
            parameters.disabled = false;
            clusteringBasedRadio.disabled = false;
            formHighLevelConvertion.disabled = true;
            networkStructure.disabled = false;

            manualRadio.checked = true;
            clusteringBasedRadio.checked = false;

            MdMC = false;
            HMdMC = true;
            MRF = false;

        }

        function changeHighLevelMapsConvertion() {
            var manualRadio = document.getElementById("manualRadio");
            var parameters = document.getElementById("parameters");
            var clusteringBasedRadio = document.getElementById("clusteringBasedRadio");
            var formHighLevelConvertion = document.getElementById("formHighLevelConvertion");

            if (parameters.disabled == true) {
                parameters.disabled = false;
                formHighLevelConvertion.disabled = true;
            } else {
                parameters.disabled = true;
                formHighLevelConvertion.disabled = false;
            }

        }
    </script>
</head>

<body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container-fluid">
            <ul class="nav navbar-nav">
                <li>
                    <a href="index.html">Home</a>
                </li>


                <li class="active">
                    <a href="#">Generate Maps</a>
                </li>


                <li>
                    <a href="help.html">Help</a>
                </li>
            </ul>
        </div>
    </nav>


    <section>
        <div id="container">
            <ul class="nav nav-tabs">
                <li class="active">
                    <a id="options" data-toggle="tab" href="#home">Options</a>
                </li>

                <li>
                    <a id="textOutput" data-toggle="tab" href="#menu1">Text Output</a>
                </li>

                <li>
                    <a id="graphicOutput" data-toggle="tab" href="#menu2">Graphic Output</a>
                </li>

                <li>
                    <a id="playMario" data-toggle="tab" href="#menu3" style="cursor:not-allowed">Play (Mario)</a>
                </li>
            </ul>


            <div class="tab-content">
                <div class="tab-pane fade in active" id="home">
                    <fieldset class="scheduler-border" id="chooseAGame">
                        <legend class="scheduler-border">Choose a Game</legend> <select class="form-control" id="formChooseAGame">
                            <option value="superMarioBros">
                                Super Mario Bros
                            </option>

                            <option value="loderunner">
                                Loderunner
                            </option>

                            <option value="kidIcarus">
                                Kid Icarus
                            </option>

                            <option value="other">
                                Other
                            </option>
                        </select>
                    </fieldset>


                    <fieldset class="scheduler-border" id="trainingMaps">
                        <legend class="scheduler-border">Training Maps</legend>

                        <div class="radio">
                            <label><input checked id="defaultMaps" name="optradio" onchange="changeTrainingMaps()" type="radio" value="default">Use default training maps</label>
                        </div>


                        <div class="radio">
                            <label><input id="userYourOwnMapsRadio" name="optradio" onchange="changeTrainingMaps()" type="radio" value="userMaps">Use your own maps</label>
                        </div>
                        <input disabled="true" id="fileinput" type="file">
                    </fieldset>


                    <fieldset class="scheduler-border" id="chooseAMethod">
                        <legend class="scheduler-border">Choose a Method</legend>

                        <div class="radio">
                            <label><input checked name="RadioChooseAMethod" onchange="changeToMdMC()" type="radio" value="MdMC"> Multi-Dimensional Markov chains (MdMC)<br></label>
                        </div>


                        <div class="radio">
                            <label><input disabled="true" name="RadioChooseAMethod" onchange="changeToHMdMC()" type="radio" value="HMdMC"> Hierarchical Multi-Dimensional Markov chains (HMdMC)<br></label>
                        </div>


                        <div class="radio">
                            <label><input disabled="true" name="RadioChooseAMethod" onchange="changeToMRF()" type="radio" value="MRF"> Markov Random Fields (MRF)<br></label>
                        </div>
                    </fieldset>


                    <fieldset class="scheduler-border" id="mapSize">
                        <legend class="scheduler-border">Map Size</legend>

                        <div class="input-group">
                            <span class="input-group-addon">Height</span> <input aria-describedby="height" class="form-control" id="height" type="text" value="12">
                        </div>
                        <br>


                        <div class="input-group">
                            <span class="input-group-addon">Width&nbsp;</span> <input aria-describedby="width" class="form-control" id="width" type="text" value="210">
                        </div>
                    </fieldset>


                    <fieldset class="scheduler-border" id="experimentalSetUps">
                        <legend class="scheduler-border">Experimental Set-Ups</legend>

                        <div id="experimentalOptions">
                            <div class="input-group">
                                <span class="input-group-addon">Row Splits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <input aria-describedby="rowSplits" class="form-control" id="rowSplits" type="text" value="12">
                            </div>
                            <br>


                            <div class="input-group">
                                <span class="input-group-addon">Lookahead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <input aria-describedby="lookahead" class="form-control" disabled="true" id="lookahead" type="text" value="0">
                            </div>
                            <br>


                            <div class="input-group">
                                <span class="input-group-addon">Network Structure&nbsp;&nbsp;</span> <input aria-describedby="networkStructure" class="form-control" id="networkStructure" type="text" value="3">
                            </div>
                        </div>


                        <div id="experimentalOptions">
                            <div class="input-group">
                                <span class="input-group-addon">Distance Metric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <input aria-describedby="distanceMetric" class="form-control" disabled="true" id="distanceMetric" type="text">
                            </div>
                            <br>


                            <div class="input-group">
                                <span class="input-group-addon">Tile Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <input aria-describedby="tileSize" class="form-control" disabled="true" id="tileSize" type="text">
                            </div>
                            <br>


                            <div class="input-group">
                                <span class="input-group-addon">Number of Clusters</span> <input aria-describedby="numberOfClusters" class="form-control" disabled="true" id="numberOfClusters" type="text">
                            </div>
                        </div>


                        <fieldset class="scheduler-border" id="experimentalFieldset">
                            <legend class="scheduler-border">Converting to High-Level Maps</legend>

                            <div id="highLevelConvertion">
                                <div class="radio">
                                    <label><input checked disabled="true" id="manualRadio" name="optradioExperimental" onchange="changeHighLevelMapsConvertion()" type="radio" value="manual">Manual</label>
                                </div>
                            </div>


                            <div id="highLevelConvertion2">
                                <div class="input-group">
                                    <span class="input-group-addon">Parameters</span> <input aria-describedby="Parameters" class="form-control" disabled="true" id="parameters" type="text">
                                </div>
                            </div>


                            <div id="highLevelConvertion">
                                <div class="radio">
                                    <label><input disabled="true" id="clusteringBasedRadio" name="optradioExperimental" onchange="changeHighLevelMapsConvertion()" type="radio" value="clusteringBased">Clustering-based</label>
                                </div>
                            </div>


                            <div id="highLevelConvertion2">
                                <select class="form-control" disabled="true" id="formHighLevelConvertion">
                                    <option value="direct">
                                        Direct
                                    </option>

                                    <option value="histogram">
                                        Histogram
                                    </option>

                                    <option value="markov">
                                        Markov
                                    </option>

                                    <option value="shape">
                                        Shape
                                    </option>

                                    <option value="weighted">
                                        Weighted
                                    </option>
                                </select>
                            </div>
                        </fieldset>
                    </fieldset>

                        <fieldset class="scheduler-border" id="generateMaps">
                            <legend class="scheduler-border">Maps</legend>

                            <div class="input-group">
                                <span class="input-group-addon">Number of maps to generate</span>
                                <input aria-describedby="height" class="form-control" id="numMaps" type="text" value="1">
                            </div>
                            <br>

                            <div>
                                <button class="btn btn-primary btn-block" id="genMultiple" onclick="genMultipleHelp()" type="button">Train and Sample maps</button>
                            </div>
                            <script>
                                var numMaps;
                                var numGenerated;

                                // Note: There needs to be some sort of delay between these steps for some reason.
                                function genMultipleHelp() {
                                    numMaps = document.getElementById("numMaps").value;
                                    numGenerated = 0;
                                    genMultiple();
                                }
                                function genMultiple() {
                                    samplingReady();
                                    window.setTimeout(genMultiple2, 1000);
                                }
                                function genMultiple2() {
                                    if (numGenerated++ == numMaps) {
                                        // Stop.
                                    } else {
                                        samplesGenerated();
                                        window.setTimeout(genMultiple(), 1000);
                                    }
                                }
                            </script>

                        </fieldset>


                    <div id="divButtons">
                        <button class="btn btn-primary btn-block" id="trainingMapsButton" onclick="samplingReady()" type="button">Training Maps</button>
                    </div>


                    <div id="divButtons2">
                        <button class="btn btn-primary btn-block" disabled="true" id="samplingMapsButton" onclick="samplesGenerated()" type="button">Sampling Maps</button>
                    </div>
                </div>


                <div class="tab-pane fade" id="menu1">
                    <div id="textOutputTab">
                    </div>
                </div>


                <div class="tab-pane fade" id="menu2">
                    <div id="graphicOutputTab">
                    </div>
                </div>


                <div class="tab-pane fade" id="menu3">
                    <div id="gameOutputTab">
                    <p> Controls: <br>
                        <ul>
                            <li>Up: W / Up Arrow / Space</li>
                            <li>Left: A / Left Arrow</li>
                            <li>Down: S / Down Arrow</li>
                            <li>Right: D / Right Arrow</li>
                            <li>Run: Left Shift / Z</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <footer>
        Drexel 2016
    </footer>
</body>
</html>